{
  "name": "simian",
  "version": "1.4.3",
  "description": "Flexible JS monkey-patching simple enough for monkey brains!",
  "author": "Yellowsink <yellowsink@protonmail.com> (https://yellowsink.vercel.app/)",
  "repository": "github:yellowsink/simian",
  "license": "BSD-3-Clause",
  "source": "src/index.ts",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "devDependencies": {
    "esbuild": "^0.14.8",
    "typescript": "^4.5.4"
  },
  "keywords": [
    "javascript",
    "js",
    "mod",
    "patcher",
    "patch",
    "monkey-patcher",
    "monkey-patch",
    "injector",
    "injection",
    "guerrilla-patcher",
    "guerrilla-injector"
  ],
  "scripts": {
    "build": "tsc",
    "bundle": "esbuild src/index.ts --bundle --outfile=dist/bundle.js",
    "prepublish": "rm -rf dist && tsc"
  },
  "readme": "# Simian\n\nFlexible JS monkey-patching simple enough for monkey brains!\n\n![npm bundle size min](https://img.shields.io/bundlephobia/min/simian?style=for-the-badge)\n![npm bundle size min gzip](https://img.shields.io/bundlephobia/minzip/simian?label=min%20%2B%20gzip%20size&style=for-the-badge)\n![npm dl monthly](https://img.shields.io/npm/dm/simian?style=for-the-badge)\n\n![CodeFactor Grade](https://img.shields.io/codefactor/grade/github/yellowsink/simian?style=for-the-badge)\n![GitHub last commit](https://img.shields.io/github/last-commit/yellowsink/simian?style=for-the-badge)\n![NPM licence](https://img.shields.io/npm/l/simian?style=for-the-badge)\n\n---\n\n## What does Simian do?\n\nMonkey-patches JS functions on-the-fly.\n\nSo if you have a function that is being used, and you want to hijack it to run your code, Simian can do that.\n\nYou can apply multiple patches to any given function, and can undo the patches in any order.\n\n## Why?\n\nOriginally cause I wanted to try make a patcher without looking at existing patchers for the challenge, but also now to be used in one of my friends' projects.\n\n## How do I use it?\n\n```ts\n// 1: import it\nimport Patcher from \"simian\";\n// 2: create a patcher\nconst patcher = new Patcher();\n// 3: some functions to patch!\nfunction wintest(a) { return a * a }\nconst obj = { objtest: (a, b) => a / b };\nwintest(5); // 25\nobj.objtest(10, 3); // 3.3333333333333335\n// 4: get patching\nconst unpatchWin = patcher.after(\"wintest\", window, (args, returnVal) => args[0] + returnVal);\nconst unpatchObj = patcher.after(\"objtest\", obj, ([a, b]), ret) => (ret + b) * a)\n// 5: the functions are now patched\nwintest(5); // 30\nobj.objtest(10, 3); // 63.33333333333334\n// 6: remove a patch\nunpatchObj();\nobj.objtest(10, 3); // 3.3333333333333335\n// 7: clean up all patches\n// also removes any data stores attached to objects not part of the patcher\npatcher.cleanupAll();\nwintest(5); // 25\n```\n\n### Types of patches: after\n\n`after` patches attach on the end of functions, and allow you to modify the return value of the function (or not! - simply don't return anything!). The original function is first called as usual, then your code is passed the args as an array, and the return value, which you can modify.\n\n```ts\npatcher.after: (funcName: string, obj: unknown, patch: (args: unknown[], ret: unknown) => unknown) => () => void\n```\n\n### Types of patches: before\n\n`before` patches attach on the front of functions, and allow you to modify the arguments of the function, before sending them on to the original function. Your code is first given the args as an array, and you simply return the args to pass to the original function, again as an array. Then the original function is called as usual with your new args.\n\n```ts\npatcher.before: (funcName: string, obj: unknown, patch: (args: unknown[]) => unknown[]) => () => void\n```\n\n### Types of patches: instead\n\n`instead` patches replace the function entirely, taking control over the args, return value, and side effects. However, if you wish to use the original function for anything (including calling it!), you are also passed it, though of course you don't need to take it as an arg - `(args, orig) => {}`, `args => {}` are both valid.\n\n```ts\npatcher.instead: (funcName: string, obj: unknown, patch: (args: unknown[], func: Function) => unknown): () => void\n```\n\n### Note\n\nYou can also pass a string to `new Patcher()` to modify the label of the patcher's data store `symbol`s.\nThis is **<u>NOT</u>** necessary for using multiple patchers at once, as every call of `Symbol()` returns a globally unique value.\n\nThis is not really useful directly, but recomended:\nit does mean that if others are going to see Simian stores while debugging theirs via devtools,\nits going to be obvious that they came from your software.\n\n## Type delcarations?\n\nSimian is written in TS, so providing type decls is a no-brainer. Just import as usual and go, Typescript decls included.\n\nNo flow types unless I get bored at some point, but probably just use flowgen.\n\n## What's up with the name?\n\nCause monkey patching, and monkeys are simians, and, uh, yeah I'm not good at names... ðŸ˜…\n\nAnd as for monkey patching itself, according to wikipedia, it comes from the earlier term _\"guerrilla patch\"_, as in stealth, and which sounds like _\"gorilla\"_."
}